//# Copyright (c) Vanderbilt University, 2010
//# ALL RIGHTS RESERVED
//# Vanderbilt University disclaims all warranties with regard to this
//# software, including all implied warranties of merchantability
//# and fitness.  In no event shall Vanderbilt University be liable for
//# any special, indirect or consequential damages or any damages
//# whatsoever resulting from loss of use, data or profits, whether
//# in an action of contract, negligence or other tortious action,
//# arising out of or in connection with the use or performance of
//# this software.
#ifndef APEX_INTERFACE_CC
#define APEX_INTERFACE_CC

#include <ACM/INTERNAL/APEX.h>
#include <ACM/USER/ACM_APEX_EXTENSIONS.h>
#include <ACM/USER/APEX_INTERFACE.h>

namespace ACM_USER {
/***************************** ACM_INTERNAL::APEX:: HELPER METHODS
 * ********************************************/

void APEX_REATTACH_SIGNAL_HANDLER() {
  ACM_INTERNAL::APEX::REATTACH_SIGNAL_HANDLERS();
}

/** AD: 11/25/2011
Adding new function addresses for user specified signal handlers. These if
provided will be invoked before the signal handler code implemented by the
emulator
*/

void SET_USER_SIGINT_HANDLER(SYSTEM_ADDRESS_TYPE entry_point) {
  ACM_INTERNAL::APEX::SET_USER_SIGINT_HANDLER(entry_point);
}

void SET_USER_SIGTERM_HANDLER(SYSTEM_ADDRESS_TYPE entry_point) {
  ACM_INTERNAL::APEX::SET_USER_SIGTERM_HANDLER(entry_point);
}

void SET_USER_PRE_START_HANDLER(/*!in*/ SYSTEM_ADDRESS_TYPE entry_point) {
  ACM_INTERNAL::APEX::SET_USER_PRE_START_HANDLER(entry_point);
}

void PRINT_CREATED_OBJECT_LIST(/*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::PRINT_CREATED_OBJECT_LIST(RETURN_CODE);
}

void GET_MY_NAME(/*!out*/ PROCESS_NAME_TYPE *PROCESS_NAME,
                 /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_MY_NAME(/*!out*/ PROCESS_NAME, /*!out*/ RETURN_CODE);
}
void GET_PROCESS_NAME(/*!in */ PROCESS_ID_TYPE PROCESS_ID,
                      /*!out*/ PROCESS_NAME_TYPE *PROCESS_NAME,
                      /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_PROCESS_NAME(PROCESS_ID, PROCESS_NAME, RETURN_CODE);
}

void SET_PARTITION_NAME(std::string NAME) {

  ACM_INTERNAL::APEX::SET_PARTITION_NAME(NAME);
}

std::string GET_PARTITION_NAME() {
  return ACM_INTERNAL::APEX::GET_PARTITION_NAME();
}

namespace DUMMY {

void DUMMY_PROCESS_1234(void) {
  while (1) {
    pthread_testcancel();
  }
}
};

void APEX_HELPER_CREATE_AND_START_DUMMY_PROCESS(RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE DUMMY_PROCESS_ID = APEX_HELPER_CREATE_PROCESS(
      INFINITE_TIME_VALUE, // SYSTEM_TIME_TYPE PERIOD,
      INFINITE_TIME_VALUE, // SYSTEM_TIME_TYPE TIME_CAPACITY,
      (SYSTEM_ADDRESS_TYPE)
          DUMMY::DUMMY_PROCESS_1234, // SYSTEM_ADDRESS_TYPE ENTRY_POINT,
      0,                             // STACK_SIZE_TYPE STACK_SIZE,
      DUMMY_PROCESS_PRIORITY,        // PRIORITY_TYPE BASE_PRIORITY,
      SOFT,                          // DEADLINE_TYPE DEADLINE,
      "DUMMY_PROCESS",               // std::string PROCESS_NAME,
      RETURN_CODE);                  // RETURN_CODE_TYPE *RETURN_CODE)
  if (*RETURN_CODE != NO_ERROR)
    return;
  START(DUMMY_PROCESS_ID, RETURN_CODE);
  LOGGER(INFO, "STARTED DUMMY PROCESS");
  return;
}

PROCESS_ID_TYPE APEX_HELPER_CREATE_PROCESS(
    SYSTEM_TIME_TYPE PERIOD, SYSTEM_TIME_TYPE TIME_CAPACITY,
    SYSTEM_ADDRESS_TYPE ENTRY_POINT, STACK_SIZE_TYPE STACK_SIZE,
    PRIORITY_TYPE BASE_PRIORITY, DEADLINE_TYPE DEADLINE,
    std::string PROCESS_NAME, RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID = -1;
  PROCESS_ATTRIBUTE_TYPE attr;
  attr.BASE_PRIORITY = BASE_PRIORITY;
  attr.PERIOD = PERIOD;
  attr.TIME_CAPACITY = TIME_CAPACITY;
  attr.DEADLINE = DEADLINE;
  attr.ENTRY_POINT = ENTRY_POINT;
  attr.STACK_SIZE = STACK_SIZE;
  if (PROCESS_NAME.size() > MAX_NAME_LENGTH) {
    *RETURN_CODE = INVALID_PARAM;
    return NEW_PROCESS_ID;
  }

  if (PROCESS_NAME.size() > MAX_NAME_LENGTH) {
    LOGGER(WARNING, "length of name %s is greater than %d. Truncating",
           PROCESS_NAME.c_str(), MAX_NAME_LENGTH);
  }
  strncpy(attr.NAME, PROCESS_NAME.c_str(), MAX_NAME_LENGTH);
  ACM_INTERNAL::APEX::CREATE_PROCESS(
      &attr, &NEW_PROCESS_ID, RETURN_CODE); // RETURN_CODE Is already an address
  return NEW_PROCESS_ID;
}

void APEX_HELPER_START_PROCESS(PROCESS_NAME_TYPE PNAME,
                               RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_START_PROCESS: GET_PROCESS_ID return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    return;
  }
  ACM_INTERNAL::APEX::START(NEW_PROCESS_ID, RETURN_CODE);
  return;
}

//! Will return NOT_AVAILABLE if trying to block on  a periodic process
void APEX_HELPER_START_PROCESS_AND_WAIT_FOR_RESPONSE(
    /*!in */ PROCESS_NAME_TYPE PNAME,
    /*!out*/ MESSAGE_ADDR_TYPE PROCESS_RESPONSE,
    /*!in */ MESSAGE_SIZE_TYPE PROCESS_RESPONSE_CAPACITY,
    /*!out*/ MESSAGE_SIZE_TYPE *PROCESS_RESPONSE_LENGTH,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_START_PROCESS: GET_PROCESS_ID return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    *PROCESS_RESPONSE_LENGTH = 0;
    return;
  }

  PROCESS_STATUS_TYPE PROCESS_STATUS;

  ACM_INTERNAL::APEX::GET_PROCESS_STATUS(
      /*!in */ NEW_PROCESS_ID,
      /*!out*/ &PROCESS_STATUS,
      /*!out*/ RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_START_PROCESS: GET_PROCESS_STATUS return code "
                  "for PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    *PROCESS_RESPONSE_LENGTH = 0;
    return;
  }

  bool isAperiodic = (PROCESS_STATUS.ATTRIBUTES.PERIOD == INFINITE_TIME_VALUE);
  ACM_INTERNAL::APEX::START(NEW_PROCESS_ID, RETURN_CODE);

  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_START_PROCESS:: START return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    *PROCESS_RESPONSE_LENGTH = 0;
    return;
  }

  if (!isAperiodic) {
    LOGGER(WARNING, "APEX_HELPER_START_PROCESS::Started. But Cannot blck for a "
                    "periodic process",
           PNAME);
    *RETURN_CODE = NOT_AVAILABLE;
    *PROCESS_RESPONSE_LENGTH = 0;
    return;
  }

  // Read from the board

  ACM_INTERNAL::APEX::GET_PROCESS_FINISHED_STATUS(
      /*!in */ NEW_PROCESS_ID,
      /*!in */ INFINITE_TIME_VALUE,
      /*!out*/ PROCESS_RESPONSE,
      /*!in */ PROCESS_RESPONSE_CAPACITY,
      /*!out*/ PROCESS_RESPONSE_LENGTH,
      /*!out*/ RETURN_CODE);
  return;
}

void APEX_HELPER_DELAYED_START_PROCESS(PROCESS_NAME_TYPE PNAME,
                                       SYSTEM_TIME_TYPE DELAY,
                                       RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_DELAYED_START_PROCESS: GET_PROCESS_ID return "
                  "code for PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    return;
  }
  ACM_INTERNAL::APEX::DELAYED_START(NEW_PROCESS_ID, DELAY, RETURN_CODE);
  return;
}

void APEX_HELPER_STOP_PROCESS(PROCESS_NAME_TYPE PNAME,
                              RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_STOP_PROCESS: GET_PROCESS_ID return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    return;
  }
  ACM_INTERNAL::APEX::STOP(NEW_PROCESS_ID, RETURN_CODE);
  return;
}
void APEX_HELPER_SUSPEND_PROCESS(PROCESS_NAME_TYPE PNAME,
                                 RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_SUSPEND_PROCESS: GET_PROCESS_ID return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    return;
  }
  ACM_INTERNAL::APEX::SUSPEND(NEW_PROCESS_ID, RETURN_CODE);
  return;
}
void APEX_HELPER_RESUME_PROCESS(PROCESS_NAME_TYPE PNAME,
                                RETURN_CODE_TYPE *RETURN_CODE) {
  PROCESS_ID_TYPE NEW_PROCESS_ID;
  ACM_INTERNAL::APEX::GET_PROCESS_ID(PNAME, &NEW_PROCESS_ID, RETURN_CODE);
  if (*RETURN_CODE != NO_ERROR) {
    LOGGER(ERROR, "APEX_HELPER_RESUME_PROCESS: GET_PROCESS_ID return code for "
                  "PROCESS_NAME %s is %d",
           PNAME, *RETURN_CODE);
    return;
  }
  ACM_INTERNAL::APEX::RESUME(NEW_PROCESS_ID, RETURN_CODE);
  return;
}

void APEX_HELPER_SET_EVENT(EVENT_NAME_TYPE EVENT_NAME,
                           RETURN_CODE_TYPE *RETURN_CODE) {
  // LOGGER("FINDING EVENT");
  EVENT_ID_TYPE EVENT_ID;
  ACM_INTERNAL::APEX::GET_EVENT_ID(EVENT_NAME, &EVENT_ID, RETURN_CODE);
  if (*RETURN_CODE == NO_ERROR) {
    ACM_INTERNAL::APEX::SET_EVENT(EVENT_ID, RETURN_CODE);
  } else {
    // LOGGER( WARNING, "APEX_HELPER_SET_EVENT return code for event_name %s is
    // %d",EVENT_NAME, *RETURN_CODE );

    return;
  }
}

void APEX_HELPER_RESET_EVENT(EVENT_NAME_TYPE EVENT_NAME,
                             RETURN_CODE_TYPE *RETURN_CODE) {
  // LOGGER("FINDING EVENT");
  EVENT_ID_TYPE EVENT_ID;
  ACM_INTERNAL::APEX::GET_EVENT_ID(EVENT_NAME, &EVENT_ID, RETURN_CODE);
  if (*RETURN_CODE == NO_ERROR) {
    ACM_INTERNAL::APEX::RESET_EVENT(EVENT_ID, RETURN_CODE);
  } else {

    // LOGGER( WARNING, "APEX_HELPER_RESET_EVENT return code for event_name %s
    // is %d",EVENT_NAME, *RETURN_CODE );

    return;
  }
}

void APEX_HELPER_WAIT_EVENT(EVENT_NAME_TYPE EVENT_NAME,
                            SYSTEM_TIME_TYPE TIME_OUT,
                            RETURN_CODE_TYPE *RETURN_CODE) {
  EVENT_ID_TYPE EVENT_ID;
  ACM_INTERNAL::APEX::GET_EVENT_ID(EVENT_NAME, &EVENT_ID, RETURN_CODE);
  if (*RETURN_CODE == NO_ERROR) {
    ACM_INTERNAL::APEX::WAIT_EVENT(EVENT_ID, TIME_OUT, RETURN_CODE);
  } else {
    // LOGGER( WARNING, "APEX_HELPER_WAIT_EVENT return code for event_name %s is
    // %d",EVENT_NAME, *RETURN_CODE );
    return;
  }
  return;
}

// Event Management Services

void CREATE_EVENT(
    /*!in */ EVENT_NAME_TYPE EVENT_NAME,
    /*!out*/ EVENT_ID_TYPE *EVENT_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_EVENT(EVENT_NAME, EVENT_ID, RETURN_CODE);
}
void SET_EVENT(
    /*!in */ EVENT_ID_TYPE EVENT_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SET_EVENT(EVENT_ID, RETURN_CODE);
}
void RESET_EVENT(
    /*!in */ EVENT_ID_TYPE EVENT_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RESET_EVENT(EVENT_ID, RETURN_CODE);
}
void WAIT_EVENT(
    /*!in */ EVENT_ID_TYPE EVENT_ID,
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::WAIT_EVENT(EVENT_ID, TIME_OUT, RETURN_CODE);
}
void GET_EVENT_ID(
    /*!in */ EVENT_NAME_TYPE EVENT_NAME,
    /*!out*/ EVENT_ID_TYPE *EVENT_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_EVENT_ID(EVENT_NAME, EVENT_ID, RETURN_CODE);
}
void GET_EVENT_STATUS(
    /*!in */ EVENT_ID_TYPE EVENT_ID,
    /*!out*/ EVENT_STATUS_TYPE *EVENT_STATUS,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_EVENT_STATUS(EVENT_ID, EVENT_STATUS, RETURN_CODE);
}

// SEMAPHORE   management services
// We currently ignore QUEUING_DISCIPLINE
void CREATE_SEMAPHORE(
    /*!in */ SEMAPHORE_NAME_TYPE SEMAPHORE_NAME,
    /*!in */ SEMAPHORE_VALUE_TYPE CURRENT_VALUE,
    /*!in */ SEMAPHORE_VALUE_TYPE MAXIMUM_VALUE,
    /*!in */ QUEUING_DISCIPLINE_TYPE QUEUING_DISCIPLINE,
    /*!out*/ SEMAPHORE_ID_TYPE *SEMAPHORE_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::CREATE_SEMAPHORE(SEMAPHORE_NAME, CURRENT_VALUE,
                                       MAXIMUM_VALUE, QUEUING_DISCIPLINE,
                                       SEMAPHORE_ID, RETURN_CODE);
}
//! Currently ignore Time_Out
void WAIT_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::WAIT_SEMAPHORE(SEMAPHORE_ID, TIME_OUT, RETURN_CODE);
}
void SIGNAL_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SIGNAL_SEMAPHORE(SEMAPHORE_ID, RETURN_CODE);
}
void GET_SEMAPHORE_ID(
    /*!in */ SEMAPHORE_NAME_TYPE SEMAPHORE_NAME,
    /*!out*/ SEMAPHORE_ID_TYPE *SEMAPHORE_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_SEMAPHORE_ID(SEMAPHORE_NAME, SEMAPHORE_ID,
                                       RETURN_CODE);
}
void GET_SEMAPHORE_STATUS(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,
    /*!out*/ SEMAPHORE_STATUS_TYPE *SEMAPHORE_STATUS,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_SEMAPHORE_STATUS(SEMAPHORE_ID, SEMAPHORE_STATUS,
                                           RETURN_CODE);
}

// PARTITION management services

void GET_PARTITION_STATUS(
    /*!out*/ PARTITION_STATUS_TYPE *PARTITION_STATUS,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_PARTITION_STATUS(PARTITION_STATUS, RETURN_CODE);
}
void SET_PARTITION_MODE(
    /*!in */ OPERATING_MODE_TYPE OPERATING_MODE,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SET_PARTITION_MODE(OPERATING_MODE, RETURN_CODE);
}

// Process management services
void CREATE_PROCESS(
    /*!in */ PROCESS_ATTRIBUTE_TYPE *ATTRIBUTES,
    /*!out*/ PROCESS_ID_TYPE *PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_PROCESS(ATTRIBUTES, PROCESS_ID, RETURN_CODE);
}
void SET_PRIORITY(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!in */ PRIORITY_TYPE PRIORITY,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SET_PRIORITY(PROCESS_ID, PRIORITY, RETURN_CODE);
}
void SUSPEND_SELF(
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SUSPEND_SELF(TIME_OUT, RETURN_CODE);
}
void SUSPEND(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SUSPEND(PROCESS_ID, RETURN_CODE);
}
void RESUME(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RESUME(PROCESS_ID, RETURN_CODE);
}

void STOP_SELF() { ACM_INTERNAL::APEX::STOP_SELF(); }
void STOP(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::STOP(PROCESS_ID, RETURN_CODE);
}

void START(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::START(PROCESS_ID, RETURN_CODE);
}
void DELAYED_START(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!in */ SYSTEM_TIME_TYPE DELAY_TIME,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::DELAYED_START(PROCESS_ID, DELAY_TIME, RETURN_CODE);
}

void GET_MY_ID(
    /*!out*/ PROCESS_ID_TYPE *PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_MY_ID(PROCESS_ID, RETURN_CODE);
}
void GET_PROCESS_ID(
    /*!in */ PROCESS_NAME_TYPE PROCESS_NAME,
    /*!out*/ PROCESS_ID_TYPE *PROCESS_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_PROCESS_ID(PROCESS_NAME, PROCESS_ID, RETURN_CODE);
}
void GET_PROCESS_STATUS(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ PROCESS_STATUS_TYPE *PROCESS_STATUS,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_PROCESS_STATUS(PROCESS_ID, PROCESS_STATUS,
                                         RETURN_CODE);
}

void NOTIFY_PROCESS_FINISHED_STATUS(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!out*/ PROCESS_RESPONSE_TYPE *PROCESS_RESPONSE,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::NOTIFY_PROCESS_FINISHED_STATUS(
      /*!in */ PROCESS_ID,
      /*!out*/ PROCESS_RESPONSE,
      /*!out*/ RETURN_CODE);
}

void GET_PROCESS_FINISHED_STATUS(
    /*!in */ PROCESS_ID_TYPE PROCESS_ID,
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ MESSAGE_ADDR_TYPE PROCESS_RESPONSE,
    /*!in */ MESSAGE_SIZE_TYPE PROCESS_RESPONSE_CAPACITY,
    /*!out*/ MESSAGE_SIZE_TYPE *PROCESS_RESPONSE_LENGTH,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_PROCESS_FINISHED_STATUS(
      /*!in */ PROCESS_ID,
      /*!in */ TIME_OUT,
      /*!out*/ PROCESS_RESPONSE,
      /*!in */ PROCESS_RESPONSE_CAPACITY,
      /*!out*/ PROCESS_RESPONSE_LENGTH,
      /*!out*/ RETURN_CODE);
}

// Time management services

void TIMED_WAIT(
    /*!in */ SYSTEM_TIME_TYPE DELAY_TIME,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::TIMED_WAIT(DELAY_TIME, RETURN_CODE);
}
void PERIODIC_WAIT(
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::PERIODIC_WAIT(RETURN_CODE);
}
void GET_TIME(
    /*!out*/ SYSTEM_TIME_TYPE *SYSTEM_TIME,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_TIME(SYSTEM_TIME, RETURN_CODE);
}

void REPLENISH(
    /*!in */ SYSTEM_TIME_TYPE BUDGET_TIME,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::REPLENISH(BUDGET_TIME, RETURN_CODE);
}

// BLACKBOARD Management Services

void CREATE_BLACKBOARD(
    /*in */ BLACKBOARD_NAME_TYPE BLACKBOARD_NAME,
    /*in */ MESSAGE_SIZE_TYPE MAX_MESSAGE_SIZE,
    /*out*/ BLACKBOARD_ID_TYPE *BLACKBOARD_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::CREATE_BLACKBOARD(BLACKBOARD_NAME, MAX_MESSAGE_SIZE,
                                        BLACKBOARD_ID, RETURN_CODE);
}
void DISPLAY_BLACKBOARD(
    /*in */ BLACKBOARD_ID_TYPE BLACKBOARD_ID,
    /*in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR, /* by reference */
    /*in */ MESSAGE_SIZE_TYPE LENGTH,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::DISPLAY_BLACKBOARD(BLACKBOARD_ID, MESSAGE_ADDR, LENGTH,
                                         RETURN_CODE);
}
void READ_BLACKBOARD(
    /*in */ BLACKBOARD_ID_TYPE BLACKBOARD_ID,
    /*in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*out*/ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /*out*/ MESSAGE_SIZE_TYPE *LENGTH,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::READ_BLACKBOARD(BLACKBOARD_ID, TIME_OUT, MESSAGE_ADDR,
                                      LENGTH, RETURN_CODE);
}
void CLEAR_BLACKBOARD(
    /*in */ BLACKBOARD_ID_TYPE BLACKBOARD_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CLEAR_BLACKBOARD(BLACKBOARD_ID, RETURN_CODE);
}
void GET_BLACKBOARD_ID(
    /*in */ BLACKBOARD_NAME_TYPE BLACKBOARD_NAME,
    /*out*/ BLACKBOARD_ID_TYPE *BLACKBOARD_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_BLACKBOARD_ID(BLACKBOARD_NAME, BLACKBOARD_ID,
                                        RETURN_CODE);
}
void GET_BLACKBOARD_STATUS(
    /*in */ BLACKBOARD_ID_TYPE BLACKBOARD_ID,
    /*out*/ BLACKBOARD_STATUS_TYPE *BLACKBOARD_STATUS,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_BLACKBOARD_STATUS(BLACKBOARD_ID, BLACKBOARD_STATUS,
                                            RETURN_CODE);
}

/////////////////////////////////////////////////////////////////////////////////////////

//! \name SAMPLING PORT Management Services
//@{
/* !
*
*/
void CREATE_SAMPLING_PORT(
    /*in */ SAMPLING_PORT_NAME_TYPE SAMPLING_PORT_NAME,
    /*in */ MESSAGE_SIZE_TYPE MAX_MESSAGE_SIZE,
    /*in */ PORT_DIRECTION_TYPE PORT_DIRECTION,
    /*in */ SYSTEM_TIME_TYPE REFRESH_PERIOD,
    /*out*/ SAMPLING_PORT_ID_TYPE *SAMPLING_PORT_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_SAMPLING_PORT(SAMPLING_PORT_NAME, MAX_MESSAGE_SIZE,
                                           PORT_DIRECTION, REFRESH_PERIOD,
                                           SAMPLING_PORT_ID, RETURN_CODE);
}
void WRITE_SAMPLING_MESSAGE(
    /*in */ SAMPLING_PORT_ID_TYPE SAMPLING_PORT_ID,
    /*in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /* by reference */ /*in */ MESSAGE_SIZE_TYPE LENGTH,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::WRITE_SAMPLING_MESSAGE(SAMPLING_PORT_ID, MESSAGE_ADDR,
                                             LENGTH, RETURN_CODE);
}
void READ_SAMPLING_MESSAGE(
    /*in */ SAMPLING_PORT_ID_TYPE SAMPLING_PORT_ID,
    /*out*/ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /*out*/ MESSAGE_SIZE_TYPE *LENGTH,
    /*out*/ VALIDITY_TYPE *VALIDITY,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::READ_SAMPLING_MESSAGE(SAMPLING_PORT_ID, MESSAGE_ADDR,
                                            LENGTH, VALIDITY, RETURN_CODE);
}
void GET_SAMPLING_PORT_ID(
    /*in */ SAMPLING_PORT_NAME_TYPE SAMPLING_PORT_NAME,
    /*out*/ SAMPLING_PORT_ID_TYPE *SAMPLING_PORT_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_SAMPLING_PORT_ID(SAMPLING_PORT_NAME, SAMPLING_PORT_ID,
                                           RETURN_CODE);
}
void GET_SAMPLING_PORT_STATUS(
    /*in */ SAMPLING_PORT_ID_TYPE SAMPLING_PORT_ID,
    /*out*/ SAMPLING_PORT_STATUS_TYPE *SAMPLING_PORT_STATUS,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_SAMPLING_PORT_STATUS(
      SAMPLING_PORT_ID, SAMPLING_PORT_STATUS, RETURN_CODE);
}

void READ_CONTENTS_TO_DATA_BUFFER(SAMPLING_PORT_ID_TYPE SAMPLING_PORT_ID,
                                  MESSAGE_ADDR_TYPE msg_ptr,
                                  MESSAGE_SIZE_TYPE MAX_LENGTH,
                                  MESSAGE_SIZE_TYPE *READ_LENGTH,
                                  RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::READ_CONTENTS_TO_DATA_BUFFER(
      SAMPLING_PORT_ID, msg_ptr, MAX_LENGTH, READ_LENGTH, RETURN_CODE);
}
void WRITE_CONTENTS_FROM_DATA_BUFFER(SAMPLING_PORT_ID_TYPE SAMPLING_PORT_ID,
                                     MESSAGE_ADDR_TYPE msg_ptr,
                                     MESSAGE_SIZE_TYPE LENGTH,
                                     RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::WRITE_CONTENTS_FROM_DATA_BUFFER(SAMPLING_PORT_ID, msg_ptr,
                                                      LENGTH, RETURN_CODE);
}

//! \name QUEUING PORT Management Services
//@{
/* !
*
*/
void CREATE_QUEUING_PORT(
    /*in */ QUEUING_PORT_NAME_TYPE QUEUING_PORT_NAME,
    /*in */ MESSAGE_SIZE_TYPE MAX_MESSAGE_SIZE,
    /*in */ MESSAGE_RANGE_TYPE MAX_NB_MESSAGE,
    /*in */ PORT_DIRECTION_TYPE PORT_DIRECTION,
    /*in */ QUEUING_DISCIPLINE_TYPE QUEUING_DISCIPLINE,
    /*out*/ QUEUING_PORT_ID_TYPE *QUEUING_PORT_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_QUEUING_PORT(
      QUEUING_PORT_NAME, MAX_MESSAGE_SIZE, MAX_NB_MESSAGE, PORT_DIRECTION,
      QUEUING_DISCIPLINE, QUEUING_PORT_ID, RETURN_CODE);
}
void SEND_QUEUING_MESSAGE(
    /*in */ QUEUING_PORT_ID_TYPE QUEUING_PORT_ID,
    /*in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR, /* by reference */
    /*in */ MESSAGE_SIZE_TYPE LENGTH,
    /*in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SEND_QUEUING_MESSAGE(QUEUING_PORT_ID, MESSAGE_ADDR,
                                           LENGTH, TIME_OUT, RETURN_CODE);
}

void MESSAGE_QUEUE_SEND_MESSAGE_FROM_BUFFER(
    QUEUING_PORT_ID_TYPE QUEUING_PORT_ID, MESSAGE_ADDR_TYPE msg_ptr,
    MESSAGE_SIZE_TYPE LENGTH, SYSTEM_TIME_TYPE TIME_OUT,
    RETURN_CODE_TYPE *RETURN_CODE)

{
  ACM_INTERNAL::APEX::MESSAGE_QUEUE_SEND_MESSAGE_FROM_BUFFER(
      QUEUING_PORT_ID, msg_ptr, LENGTH, TIME_OUT, RETURN_CODE);
}
void RECEIVE_QUEUING_MESSAGE(
    /*in */ QUEUING_PORT_ID_TYPE QUEUING_PORT_ID,
    /*in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*out*/ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /*out*/ MESSAGE_SIZE_TYPE *LENGTH,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RECEIVE_QUEUING_MESSAGE(
      QUEUING_PORT_ID, TIME_OUT, MESSAGE_ADDR, LENGTH, RETURN_CODE);
}
void GET_QUEUING_PORT_ID(
    /*in */ QUEUING_PORT_NAME_TYPE QUEUING_PORT_NAME,
    /*out*/ QUEUING_PORT_ID_TYPE *QUEUING_PORT_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_QUEUING_PORT_ID(QUEUING_PORT_NAME, QUEUING_PORT_ID,
                                          RETURN_CODE);
}
void GET_QUEUING_PORT_STATUS(
    /*in */ QUEUING_PORT_ID_TYPE QUEUING_PORT_ID,
    /*out*/ QUEUING_PORT_STATUS_TYPE *QUEUING_PORT_STATUS,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_QUEUING_PORT_STATUS(QUEUING_PORT_ID,
                                              QUEUING_PORT_STATUS, RETURN_CODE);
}

////////////////////////////////////////
void CREATE_BUFFER(BUFFER_NAME_TYPE BUFFER_NAME,
                   MESSAGE_SIZE_TYPE MAX_MESSAGE_SIZE,
                   MESSAGE_RANGE_TYPE MAX_NB_MESSAGE,
                   QUEUING_DISCIPLINE_TYPE QUEUING_DISCIPLINE,
                   BUFFER_ID_TYPE *BUFFER_ID, RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_BUFFER(BUFFER_NAME, MAX_MESSAGE_SIZE,
                                    MAX_NB_MESSAGE, QUEUING_DISCIPLINE,
                                    BUFFER_ID, RETURN_CODE);
}
void SEND_BUFFER(/*in */ BUFFER_ID_TYPE BUFFER_ID,
                 /*in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
                 /* by reference */ /*in */ MESSAGE_SIZE_TYPE LENGTH,
                 /*in */ SYSTEM_TIME_TYPE TIME_OUT,
                 /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::SEND_BUFFER(/*in */ BUFFER_ID, /*in */ MESSAGE_ADDR,
                                  /* by reference */ /*in */ LENGTH,
                                  /*in */ TIME_OUT, /*out*/ RETURN_CODE);
}
void RECEIVE_BUFFER(/*in */ BUFFER_ID_TYPE BUFFER_ID,
                    /*in */ SYSTEM_TIME_TYPE TIME_OUT,
                    /*out*/ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
                    /*out*/ MESSAGE_SIZE_TYPE *LENGTH,
                    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RECEIVE_BUFFER(/*in */ BUFFER_ID, /*in */ TIME_OUT,
                                     /*out*/ MESSAGE_ADDR, /*out*/ LENGTH,
                                     /*out*/ RETURN_CODE);
}
void GET_BUFFER_ID(/*in */ BUFFER_NAME_TYPE BUFFER_NAME,
                   /*out*/ BUFFER_ID_TYPE *BUFFER_ID,
                   /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_BUFFER_ID(/*in */ BUFFER_NAME, /*out*/ BUFFER_ID,
                                    /*out*/ RETURN_CODE);
}
void GET_BUFFER_STATUS(/*in */ BUFFER_ID_TYPE BUFFER_ID,
                       /*out*/ BUFFER_STATUS_TYPE *BUFFER_STATUS,
                       /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::GET_BUFFER_STATUS(
      /*in */ BUFFER_ID, /*out*/ BUFFER_STATUS, /*out*/ RETURN_CODE);
}

/////////////////////////////////////////////////////////////

void CREATE_HEALTH_MANAGER_PROCESS(
    /*in*/ SYSTEM_ADDRESS_TYPE ENTRY_POINT,
    /*in*/ PROCESS_NAME_TYPE PROCESS_NAME,
    /*in*/ STACK_SIZE_TYPE STACK_SIZE,
    /*out*/ HM_DESCRIPTOR_ID_TYPE *HM_DESCRIPTOR_ID,
    /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::CREATE_HEALTH_MANAGER_PROCESS(/*in*/ ENTRY_POINT,
                                                    /*in*/ PROCESS_NAME,
                                                    /*in*/ STACK_SIZE,
                                                    /*out*/ HM_DESCRIPTOR_ID,
                                                    /*out*/ RETURN_CODE);
}

void REGISTER_PROCESS_WITH_HEALTH_MANAGER(
    PROCESS_ID_TYPE PROCESS_ID, HM_DESCRIPTOR_ID_TYPE HM_DESCRIPTOR_ID,
    BLACKBOARD_ID_TYPE *BLACKBOARD_ID, /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::REGISTER_PROCESS_WITH_HEALTH_MANAGER(
      PROCESS_ID, HM_DESCRIPTOR_ID, BLACKBOARD_ID, /*out*/ RETURN_CODE);
}

void START_HM(/*!in */ HM_DESCRIPTOR_ID_TYPE HM_DESCRIPTOR_ID,
              /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::START_HM(/*!in */ HM_DESCRIPTOR_ID, /*!out*/ RETURN_CODE);
}

void HM_GET_MY_BUFFER_ID(/*OUT*/ BUFFER_ID_TYPE *BUFFER_ID,
                         /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::HM_GET_MY_BUFFER_ID(/*OUT*/ BUFFER_ID,
                                          /*out*/ RETURN_CODE);
}

void RAISE_APPLICATION_ERROR(/*!in */ ERROR_CODE_TYPE ERROR_CODE,
                             /*!in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
                             /*!in */ ERROR_MESSAGE_SIZE_TYPE LENGTH,
                             /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RAISE_APPLICATION_ERROR(
      /*!in */ ERROR_CODE, /*!in */ MESSAGE_ADDR, /*!in */ LENGTH,
      /*!out*/ RETURN_CODE);
}
void HM_GET_PROCESS_ERROR_MESSAGE(/*out*/ ERROR_STATUS_TYPE *ERROR_STATUS,
                                  /*out*/ BLACKBOARD_ID_TYPE *TARGET_BBOARD_ID,
                                  /*out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::HM_GET_PROCESS_ERROR_MESSAGE(
      ERROR_STATUS, TARGET_BBOARD_ID, RETURN_CODE);
}

void HM_NOTIFY_PROCESS(/*!in*/ PROCESS_ID_TYPE PROCESS_ID,
                       /*!in*/ HM_RESPONSE_TYPE *HM_RESPONSE,
                       /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::HM_NOTIFY_PROCESS(PROCESS_ID, HM_RESPONSE, RETURN_CODE);
}

void RAISE_APPLICATION_ERROR_AND_GET_RESPONSE(
    /*!in */ ERROR_CODE_TYPE ERROR_CODE,
    /*!in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /*!in */ ERROR_MESSAGE_SIZE_TYPE LENGTH,
    /*!in */ SYSTEM_TIME_TYPE
        TIME_OUT, // Added Timeout in response to the discussion with Gabor
    /*!out*/ HM_RESPONSE_TYPE *HM_RESPONSE,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RAISE_APPLICATION_ERROR_AND_GET_RESPONSE(
      /*!in */ ERROR_CODE,
      /*!in */ MESSAGE_ADDR,
      /*!in */ LENGTH,
      /*!in */ TIME_OUT, // Added Timeout in response to the discussion with
                         // Gabor
      /*!out*/ HM_RESPONSE,
      /*!out*/ RETURN_CODE);
}

// void RAISE_APPLICATION_ERROR_AND_GET_RESPONSE (	/*!in */ ERROR_CODE_TYPE
// ERROR_CODE,
//	/*!in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
//	/*!in */ ERROR_MESSAGE_SIZE_TYPE LENGTH,
//	/*!out*/ MESSAGE_ADDR_TYPE HM_RESPONSE,
//	/*!in */ MESSAGE_SIZE_TYPE HM_RESPONSE_CAPACITY,
//	/*!in */ SYSTEM_TIME_TYPE TIME_OUT, //Added Timeout in response to the
//discussion with Gabor
//	/*out*/ MESSAGE_SIZE_TYPE *HM_RESPONSE_LENGTH,
//	/*!out*/ RETURN_CODE_TYPE *RETURN_CODE )
//{
//	ACM_INTERNAL::APEX::RAISE_APPLICATION_ERROR_AND_GET_RESPONSE (
///*!in */  ERROR_CODE,
//		/*!in */  MESSAGE_ADDR,
//		/*!in */  LENGTH,
//		/*!out*/  HM_RESPONSE,
//		/*!in */  HM_RESPONSE_CAPACITY,
//		TIME_OUT,
//		/*out*/ HM_RESPONSE_LENGTH,
//		/*!out*/ RETURN_CODE );
//}

void RAISE_APPLICATION_ERROR(
    /*!in*/ PROCESS_ID_TYPE FAULTY_PROCESS_ID,
    /*!in */ ERROR_CODE_TYPE ERROR_CODE,
    /*!in */ MESSAGE_ADDR_TYPE MESSAGE_ADDR,
    /*!in */ ERROR_MESSAGE_SIZE_TYPE LENGTH,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {
  ACM_INTERNAL::APEX::RAISE_APPLICATION_ERROR(
      /*!in*/ FAULTY_PROCESS_ID,
      /*!in */ ERROR_CODE,
      /*!in */ MESSAGE_ADDR,
      /*!in */ LENGTH,
      /*!out*/ RETURN_CODE);
}

////////////////////////////////////////////////////////////// RW LOCK
//////////////////////////////////////////
void CREATE_RW_SEMAPHORE(
    /*!in */ SEMAPHORE_NAME_TYPE SEMAPHORE_NAME,
    /*!in */ SEMAPHORE_VALUE_TYPE MAXIMUM_READERS,
    /*!out*/ SEMAPHORE_ID_TYPE *SEMAPHORE_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::CREATE_RW_SEMAPHORE(SEMAPHORE_NAME, MAXIMUM_READERS,
                                          SEMAPHORE_ID, RETURN_CODE);
}
void GET_RW_SEMAPHORE_ID(
    /*!in */ SEMAPHORE_NAME_TYPE SEMAPHORE_NAME,
    /*!out*/ SEMAPHORE_ID_TYPE *SEMAPHORE_ID,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::GET_RW_SEMAPHORE_ID(SEMAPHORE_NAME, SEMAPHORE_ID,
                                          RETURN_CODE);
}

//! Currently ignore Time_Out
void READLOCK_RW_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::READLOCK_RW_SEMAPHORE(
      /*!in */ SEMAPHORE_ID,
      /*!in */ TIME_OUT,
      /*!out*/ RETURN_CODE);
}

void READUNLOCK_RW_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,

    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::READUNLOCK_RW_SEMAPHORE(
      /*!in */ SEMAPHORE_ID,

      /*!out*/ RETURN_CODE);
}

void WRITELOCK_RW_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,
    /*!in */ SYSTEM_TIME_TYPE TIME_OUT,
    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::WRITELOCK_RW_SEMAPHORE(
      /*!in */ SEMAPHORE_ID,
      /*!in */ TIME_OUT,
      /*!out*/ RETURN_CODE);
}

void WRITEUNLOCK_RW_SEMAPHORE(
    /*!in */ SEMAPHORE_ID_TYPE SEMAPHORE_ID,

    /*!out*/ RETURN_CODE_TYPE *RETURN_CODE) {

  ACM_INTERNAL::APEX::WRITEUNLOCK_RW_SEMAPHORE(
      /*!in */ SEMAPHORE_ID,

      /*!out*/ RETURN_CODE);
}
}
#endif
